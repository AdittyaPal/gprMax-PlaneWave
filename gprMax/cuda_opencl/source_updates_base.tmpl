// Copyright (C) 2015-2022: The University of Edinburgh, United Kingdom
//                 Authors: Craig Warren, Antonis Giannopoulos, and John Hartley
//
// This file is part of gprMax.
//
// gprMax is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// gprMax is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with gprMax.  If not, see <http://www.gnu.org/licenses/>.


// Macros for converting subscripts to linear index:
#define IDX2D_MAT(m, n) (m)*({{NY_MATCOEFFS}})+(n)
#define IDX2D_SRCINFO(m, n) (m)*{{NY_SRCINFO}}+(n)
#define IDX2D_SRCWAVES(m, n) (m)*({{NY_SRCWAVES}})+(n)
#define IDX3D_FIELDS(i, j, k) (i)*({{NY_FIELDS}})*({{NZ_FIELDS}})+(j)*({{NZ_FIELDS}})+(k)
#define IDX4D_ID(p, i, j, k) (p)*({{NX_ID}})*({{NY_ID}})*({{NZ_ID}})+(i)*({{NY_ID}})*({{NZ_ID}})+(j)*({{NZ_ID}})+(k)

// Material coefficients (read-only) stored in constant memory of compute device
{% block constmem %}{% endblock constmem %}

///////////////////////////////////////////
// Hertzian dipole electric field update //
///////////////////////////////////////////

{{KERNEL}} void update_hertzian_dipole(int NHERTZDIPOLE, 
                                      int iteration, 
                                      {{REAL}} dx, 
                                      {{REAL}} dy, 
                                      {{REAL}} dz,{% filter indent(width=37) %}{% block electric_source_args %}{% endblock electric_source_args %}{% endfilter %}{

    //  This function updates electric field values for Hertzian dipole sources.
    //
    //  Args:
    //      NHERTZDIPOLE: Total number of Hertzian dipoles in the model
    //      iteration: Iteration number of simulation
    //      dx, dy, dz: Spatial discretisations
    //      srcinfo1: Source cell coordinates and polarisation information
    //      srcinfo2: Other source information, e.g. length, resistance etc...
    //      srcwaveforms: Source waveform values
    //      ID, E: Access to ID and field component arrays

    // Obtain the linear index corresponding to the current thread and use for each receiver
    {% block threadidx %}{% endblock threadidx %}

    if (src < NHERTZDIPOLE) {

        {{REAL}} dl;
        int i, j, k, polarisation;

        i = srcinfo1[IDX2D_SRCINFO(src,0)];
        j = srcinfo1[IDX2D_SRCINFO(src,1)];
        k = srcinfo1[IDX2D_SRCINFO(src,2)];
        polarisation = srcinfo1[IDX2D_SRCINFO(src,3)];
        dl = srcinfo2[src];

        // 'x' polarised source
        if (polarisation == 0) {
            int materialEx = ID[IDX4D_ID(0,i,j,k)];
            Ex[IDX3D_FIELDS(i,j,k)] = Ex[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEx,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * dl * (1 / (dx * dy * dz));
        }

        // 'y' polarised source
        else if (polarisation == 1) {
            int materialEy = ID[IDX4D_ID(1,i,j,k)];
            Ey[IDX3D_FIELDS(i,j,k)] = Ey[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEy,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * dl * (1 / (dx * dy * dz));
        }

        // 'z' polarised source
        else if (polarisation == 2) {
            int materialEz = ID[IDX4D_ID(2,i,j,k)];
            Ez[IDX3D_FIELDS(i,j,k)] = Ez[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEz,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * dl * (1 / (dx * dy * dz));
        }
    }
}


///////////////////////////////////////////
// Magnetic dipole magnetic field update //
///////////////////////////////////////////

{{KERNEL}} void update_magnetic_dipole(int NMAGDIPOLE, 
                                     int iteration, 
                                     {{REAL}} dx, 
                                     {{REAL}} dy, 
                                     {{REAL}} dz,{% filter indent(width=37) %}{% block magnetic_source_args %}{% endblock magnetic_source_args %}{% endfilter %}{

    //  This function updates magnetic field values for magnetic dipole sources.
    //
    //  Args:
    //      NMAGDIPOLE: Total number of magnetic dipoles in the model
    //      iteration: Iteration number of simulation
    //      dx, dy, dz: Spatial discretisations
    //      srcinfo1: Source cell coordinates and polarisation information
    //      srcinfo2: Other source information, e.g. length, resistance etc...
    //      srcwaveforms: Source waveform values
    //      ID, H: Access to ID and field component arrays

    // Obtain the linear index corresponding to the current thread and use for each receiver
    {{self.threadidx()}}

    if (src < NMAGDIPOLE) {

        int i, j, k, polarisation;

        i = srcinfo1[IDX2D_SRCINFO(src,0)];
        j = srcinfo1[IDX2D_SRCINFO(src,1)];
        k = srcinfo1[IDX2D_SRCINFO(src,2)];
        polarisation = srcinfo1[IDX2D_SRCINFO(src,3)];

        // 'x' polarised source
        if (polarisation == 0) {
            int materialHx = ID[IDX4D_ID(3,i,j,k)];
            Hx[IDX3D_FIELDS(i,j,k)] = Hx[IDX3D_FIELDS(i,j,k)] - updatecoeffsH[IDX2D_MAT(materialHx,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (dx * dy * dz));
        }

        // 'y' polarised source
        else if (polarisation == 1) {
            int materialHy = ID[IDX4D_ID(4,i,j,k)];
            Hy[IDX3D_FIELDS(i,j,k)] = Hy[IDX3D_FIELDS(i,j,k)] - updatecoeffsH[IDX2D_MAT(materialHy,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (dx * dy * dz));
        }

        // 'z' polarised source
        else if (polarisation == 2) {
            int materialHz = ID[IDX4D_ID(5,i,j,k)];
            Hz[IDX3D_FIELDS(i,j,k)] = Hz[IDX3D_FIELDS(i,j,k)] - updatecoeffsH[IDX2D_MAT(materialHz,4)] * 
                                      srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (dx * dy * dz));
        }
    }
}


//////////////////////////////////////////
// Voltage source electric field update //
//////////////////////////////////////////

{{KERNEL}} void update_voltage_source(int NVOLTSRC, 
                                    int iteration, 
                                    {{REAL}} dx, 
                                    {{REAL}} dy, 
                                    {{REAL}} dz,{% filter indent(width=36) %}{{self.electric_source_args()}}{% endfilter %}{

    //  This function updates electric field values for voltage sources.
    //
    //  Args:
    //      NVOLTSRC: Total number of voltage sources in the model
    //      iteration: Iteration number of simulation
    //      dx, dy, dz: Spatial discretisations
    //      srcinfo1: Source cell coordinates and polarisation information
    //      srcinfo2: Other source information, e.g. length, resistance etc...
    //      srcwaveforms: Source waveform values
    //      ID, E: Access to ID and field component arrays

    // Obtain the linear index corresponding to the current thread and use for each receiver
    {{self.threadidx()}}

    if (src < NVOLTSRC) {

        {{REAL}} resistance;
        int i, j, k, polarisation;

        i = srcinfo1[IDX2D_SRCINFO(src,0)];
        j = srcinfo1[IDX2D_SRCINFO(src,1)];
        k = srcinfo1[IDX2D_SRCINFO(src,2)];
        polarisation = srcinfo1[IDX2D_SRCINFO(src,3)];
        resistance = srcinfo2[src];

        // 'x' polarised source
        if (polarisation == 0) {
            if (resistance != 0) {
                int materialEx = ID[IDX4D_ID(0,i,j,k)];
                Ex[IDX3D_FIELDS(i,j,k)] = Ex[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEx,4)] * 
                                          srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (resistance * dy * dz));
            }
            else {
                Ex[IDX3D_FIELDS(i,j,k)] = -1 * srcwaveforms[IDX2D_SRCWAVES(src,iteration)] / dx;
            }
        }

        // 'y' polarised source
        else if (polarisation == 1) {
            if (resistance != 0) {
                int materialEy = ID[IDX4D_ID(1,i,j,k)];
                Ey[IDX3D_FIELDS(i,j,k)] = Ey[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEy,4)] * 
                                          srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (resistance * dx * dz));
            }
            else {
                Ey[IDX3D_FIELDS(i,j,k)] = -1 * srcwaveforms[IDX2D_SRCWAVES(src,iteration)] / dy;
            }
        }

        // 'z' polarised source
        else if (polarisation == 2) {
            if (resistance != 0) {
                int materialEz = ID[IDX4D_ID(2,i,j,k)];
                Ez[IDX3D_FIELDS(i,j,k)] = Ez[IDX3D_FIELDS(i,j,k)] - updatecoeffsE[IDX2D_MAT(materialEz,4)] * 
                                          srcwaveforms[IDX2D_SRCWAVES(src,iteration)] * (1 / (resistance * dx * dy));
            }
            else {
                Ez[IDX3D_FIELDS(i,j,k)] = -1 * srcwaveforms[IDX2D_SRCWAVES(src,iteration)] / dz;
            }
        }
    }
}
