// Copyright (C) 2015-2022: The University of Edinburgh, United Kingdom
//                 Authors: Craig Warren, Antonis Giannopoulos, and John Hartley
//
// This file is part of gprMax.
//
// gprMax is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// gprMax is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with gprMax.  If not, see <http://www.gnu.org/licenses/>.


// Macros for converting subscripts to linear index:
#define IDX3D_FIELDS(i, j, k) (i)*({{NY_FIELDS}})*({{NZ_FIELDS}})+(j)*({{NZ_FIELDS}})+(k)
#define IDX4D_SNAPS(p, i, j, k) (p)*({{NX_SNAPS}})*({{NY_SNAPS}})*({{NZ_SNAPS}})+(i)*({{NY_SNAPS}})*({{NZ_SNAPS}})+(j)*({{NZ_SNAPS}})+(k)

////////////////////
// Store snapshot //
////////////////////

{{KERNEL}} void store_snapshot(int p, 
                             int xs, 
                             int xf, 
                             int ys, 
                             int yf, 
                             int zs, 
                             int zf, 
                             int dx, 
                             int dy, 
                             int dz,{% filter indent(width=29) %}{% block snap_args %}{% endblock snap_args %}{% endfilter %}{

    //  This function stores field values for a snapshot.
    //
    //  Args:
    //      p: Snapshot number
    //      xs, xf, ys, yf, xs, xf: Start and finish cell coordinates for snapshot
    //      dx, dy, dz: Sampling interval in cell coordinates for snapshot
    //      E, H: Access to field component arrays
    //      snapEx, snapEy, snapEz, snapHx, snapHy, snapHz: Access to arrays to store snapshots

    // Obtain the linear index corresponding to the current thread
    {% block threadidx %}{% endblock threadidx %}

    // Convert the linear index to subscripts for 4D SNAPS array
    int i = (idx % ({{NX_SNAPS}} * {{NY_SNAPS}} * {{NZ_SNAPS}})) / ({{NY_SNAPS}} * {{NZ_SNAPS}});
    int j = ((idx % ({{NX_SNAPS}} * {{NY_SNAPS}} * {{NZ_SNAPS}})) % ({{NY_SNAPS}} * {{NZ_SNAPS}})) / {{NZ_SNAPS}};
    int k = ((idx % ({{NX_SNAPS}} * {{NY_SNAPS}} * {{NZ_SNAPS}})) % ({{NY_SNAPS}} * {{NZ_SNAPS}})) % {{NZ_SNAPS}};

    // Subscripts for field arrays
    int ii, jj, kk;

    if (i >= xs && i < xf && j >= ys && j < yf && k >= zs && k < zf) {

        // Increment subscripts for field array to account for spatial sampling of snapshot
        ii = (xs + i) * dx;
        jj = (ys + j) * dy;
        kk = (zs + k) * dz;

        // The electric field component value at a point comes from an average of
        // the 4 electric field component values in that cell
        snapEx[IDX4D_SNAPS(p,i,j,k)] = (Ex[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Ex[IDX3D_FIELDS(ii,jj+1,kk)] + 
                                        Ex[IDX3D_FIELDS(ii,jj,kk+1)] + 
                                        Ex[IDX3D_FIELDS(ii,jj+1,kk+1)]) / 4;
        snapEy[IDX4D_SNAPS(p,i,j,k)] = (Ey[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Ey[IDX3D_FIELDS(ii+1,jj,kk)] + 
                                        Ey[IDX3D_FIELDS(ii,jj,kk+1)] + 
                                        Ey[IDX3D_FIELDS(ii+1,jj,kk+1)]) / 4;
        snapEz[IDX4D_SNAPS(p,i,j,k)] = (Ez[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Ez[IDX3D_FIELDS(ii+1,jj,kk)] + 
                                        Ez[IDX3D_FIELDS(ii,jj+1,kk)] + 
                                        Ez[IDX3D_FIELDS(ii+1,jj+1,kk)]) / 4;

        // The magnetic field component value at a point comes from average of
        // 2 magnetic field component values in that cell and the following cell
        snapHx[IDX4D_SNAPS(p,i,j,k)] = (Hx[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Hx[IDX3D_FIELDS(ii+1,jj,kk)]) / 2;
        snapHy[IDX4D_SNAPS(p,i,j,k)] = (Hy[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Hy[IDX3D_FIELDS(ii,jj+1,kk)]) / 2;
        snapHz[IDX4D_SNAPS(p,i,j,k)] = (Hz[IDX3D_FIELDS(ii,jj,kk)] + 
                                        Hz[IDX3D_FIELDS(ii,jj,kk+1)]) / 2;
    }
}